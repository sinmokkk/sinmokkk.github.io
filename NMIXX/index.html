<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NMIXX</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: linear-gradient(to bottom, #0050a1, #001933);
    }

    .ocean {
      display: flex; 
      justify-content: center; 
      align-items: center; 
      width: 100%;
      height: 100vh;
      overflow: hidden;
      position: relative;
      background: radial-gradient(circle, #00bfff, #0099cc 60%, #004c99 100%);
    }

    .contain {
      z-index: 10;
      width: 650px;
      height: 400px;
      background: rgba(0, 0, 0, 0.3);
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 1rem;
      box-shadow:
        0 4px 10px rgba(0, 0, 0, 0.7),
        inset 0 0 30px rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }

    .scene {
      z-index: 10;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.3);
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 1rem;
      box-shadow:
        0 4px 10px rgba(0, 0, 0, 0.7),
        inset 0 0 30px rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      position: relative;
      display: none;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }

    button {
      padding: 10px 20px;
      font-size: 1.2rem;
      margin: 10px;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      background: #0050a1;
      color: white;
      transition: background 0.3s ease;
    }

    button:hover {
      background: #003d80;
    }

    button:active {
      background: #002b60;
    }

    .screen {
      width: 95%;
      height: 85%;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 0.75rem;
      overflow: hidden;
      position: relative;
      box-shadow:
        inset 0 0 10px rgba(255, 255, 255, 0.3),
        inset 0 0 30px rgba(0, 0, 0, 0.7);
      display: flex;
      flex-direction: row;
      overflow-x: auto;
      scroll-snap-type: x mandatory; /* 啟用強制對齊 */
      scrollbar-width: none; /* 隱藏滾動條 */
    }

    .screen::-webkit-scrollbar {
      display: none; /* 隱藏滾動條 */
    }

    .page {
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.2));
      border-radius: 0.75rem;
      flex: 0 0 100%;
      width: 100%;
      height: 100%;
      scroll-snap-align: start; /* 對齊到容器的起始點 */
      text-align: center;
      color: #fff;
      font-size: 2rem;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .navigation {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      justify-content: space-between;
      width: 100%;
      pointer-events: none;
    }

    .nav-button {
      background: rgba(0, 0, 0, 0.5);
      color: white;
      border: none;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      font-size: 1.5rem;
      display: flex;
      justify-content: center;
      align-items: center;
      pointer-events: all;
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.7);
      transition: transform 0.2s ease;
    }

    .nav-button:hover {
      transform: scale(1.1);
    }

    .nav-button:active {
      transform: scale(1);
    }

    .nav-prev {
      position: absolute;
      left: 10px;
    }

    .nav-next {
      position: absolute;
      right: 10px;
    }

    /* 雜訊層 */
    .static-noise {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: black;
      z-index: 1000;
      pointer-events: none;
      animation: noise 0.15s infinite, colorShift 1.5s infinite alternate;
    }

    @keyframes noise {
      0%, 100% {
        background: repeating-linear-gradient(
          0deg,
          rgba(0, 0, 0, 0.9) 0px,
          rgba(255, 255, 255, 0.08) 2px,
          rgba(0, 0, 0, 0.9) 4px
        );
      }
      50% {
        background: repeating-linear-gradient(
          90deg,
          rgba(0, 0, 0, 0.9) 0px,
          rgba(255, 255, 255, 0.1) 3px,
          rgba(0, 0, 0, 0.9) 6px
        );
      }
    }

    @keyframes colorShift {
      0% {
        filter: hue-rotate(0deg);
      }
      100% {
        filter: hue-rotate(20deg);
      }
    }

    .logo-team {
      opacity: 0;
      transform: translateY(20px);
      animation: fadeIn 1s ease-out forwards;
    }

    /* 定義 fadeIn 動畫 */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .logo-box {
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: space-around;
    }

    .logo {
      position: relative;
      display: flex;
      justify-content: center;
    }

    .text {
      stroke-dasharray: 900;
      stroke-dashoffset: 900;
      animation: text-animation 4s forwards 1;
      animation: none;
    }

    .logo-team.play-text .text {
      animation: text-animation 4s forwards;
      animation-delay: 0s; /* 延遲由 JavaScript 動態控制 */
    }

    @keyframes text-animation {
      75% {
        fill: transparent;
        stroke-dashoffset: 0;
        stroke-width: 5px;
      }
      100% {
        fill: #F3F3F3;
        stroke-dashoffset: 0;
        stroke-width: 0;
      }
    }

    /* 淡出效果 */
    .fade-out {
      animation: fadeOut 1.2s forwards;
    }

    @keyframes fadeOut {
      to {
        opacity: 0;
        visibility: hidden;
      }
    }

    /* 螢光字效果 */
    .nmixx-text {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(1);
      color: #00ccff;
      font-size: 5rem;
      font-weight: bold;
      text-shadow: 
        0 0 10px #00ccff, 
        0 0 20px #00ccff, 
        0 0 30px #00ccff,
        0 0 40px #00ffff;
      opacity: 0;
      z-index: 1001;
      animation: textEffect 2.5s forwards 5s;
    }

    @keyframes textEffect {
      0% {
        opacity: 0;
        text-shadow: 0 0 10px #00ccff;
        transform: translate(-50%, -50%) scale(0.8);
      }
      50% {
        opacity: 1;
        text-shadow: 0 0 30px #00ccff, 0 0 60px #00ffff;
        transform: translate(-50%, -50%) scale(1.2);
      }
      100% {
        text-shadow: 0 0 10px #00ccff, 0 0 20px #00ffff;
        transform: translate(-50%, -50%) scale(1);
      }
    }

    .bubble {
      position: absolute;
      bottom: -100px;
      width: 40px;
      height: 40px;
      background: radial-gradient(circle at 30% 30%, rgba(0, 240, 255, 0.8), rgba(0, 180, 255, 0.6) 40%, rgba(0, 150, 255, 0.3) 70%);
      border-radius: 50%;
      box-shadow: 
        0 0 30px 10px rgba(0, 220, 255, 0.8), 
        inset -10px -10px 20px rgba(0, 240, 255, 0.9), 
        inset 10px 10px 25px rgba(0, 100, 200, 0.4);
      animation: rise 8s infinite ease-in-out, shine 3s infinite alternate;
      opacity: 0.9;
    }

    @keyframes rise {
      0% {
        transform: translateY(0) scale(0.8);
      }
      100% {
        transform: translateY(-120vh) scale(1.2);
      }
    }

    @keyframes shine {
      0% {
        filter: brightness(1);
      }
      100% {
        filter: brightness(1.4);
      }
    }
  </style>
</head>
<body>
  
  <!-- 雜訊層 -->
  <div class="static-noise">
    <div class="logo-box">
      <!-- 1 -->
      <div class="logo-team">
        <div class="logo">
          <svg style="display: flex; justify-content: left;" width="100%" height="160px" viewBox="0 0 600 160" preserveAspectRatio="xMidYMid meet">
            <text 
              fill="none" 
              stroke="#ee0000" 
              x="0" 
              y="120" 
              stroke-width="5" 
              font-size="100" 
              font-family="'Raleway', sans-serif" 
              font-weight="800" 
              class="text">
              外貌Check!
            </text>
          </svg>
        </div>
        <div class="logo">
          <svg  width="100%" height="160px" viewBox="0 0 600 160" preserveAspectRatio="xMidYMid meet">
            <text 
              fill="none" 
              stroke="#ee0000" 
              x="0" 
              y="120" 
              stroke-width="5" 
              font-size="100" 
              font-family="'Raleway', sans-serif" 
              font-weight="800" 
              class="text">
              外貌Check!
            </text>
          </svg>
        </div>
      </div>
      <!-- 2 -->
      <div class="logo-team">
        <div class="logo">
          <svg style="display: flex; justify-content: left;" width="100%" height="160px" viewBox="0 0 600 160" preserveAspectRatio="xMidYMid meet">
            <text 
              fill="none" 
              stroke="#ee0000" 
              x="0" 
              y="120" 
              stroke-width="5" 
              font-size="100" 
              font-family="'Raleway', sans-serif" 
              font-weight="800" 
              class="text">
              外貌Check!
            </text>
          </svg>
        </div>
        <div class="logo">
          <svg  width="100%" height="160px" viewBox="0 0 600 160" preserveAspectRatio="xMidYMid meet">
            <text 
              fill="none" 
              stroke="#ee0000" 
              x="0" 
              y="120" 
              stroke-width="5" 
              font-size="100" 
              font-family="'Raleway', sans-serif" 
              font-weight="800" 
              class="text">
              外貌Check!
            </text>
          </svg>
        </div>
      </div>
    </div>
  </div>

  <!-- 螢光字 -->
  <div class="nmixx-text">NMIXX</div>

  <button onclick="goBack()" id="gobackButton" style="position: absolute; top: 10px; left: 10px; z-index: 11; display: none;">返回主頁</button>

  <div class="ocean">
    <div class="contain">
      <!-- 電視的屏幕部分 -->
      <div class="screen">
        <div class="page">
          <button onclick="show3D()">進入 3D 場景</button>
        </div>
        <div class="page">Page 2</div>
        <div class="page">Page 3</div>
      </div>

      <!-- 左右導航按鈕 -->
      <div class="navigation">
        <button class="nav-button nav-prev" onclick="scrollScreen(-1)">&#8249;</button>
        <button class="nav-button nav-next" onclick="scrollScreen(1)">&#8250;</button>
      </div>
    </div>
    <!-- 3D 場景頁面 -->
    <div class="scene">
      <div class="contain">
        <script src='-3D-main/js/three.min.js'></script>
        <script src='-3D-main/js/TrackballControls.js'></script>
        <script src='-3D-main/js/simplex-noise.js'></script>
        <script src='-3D-main/js/OBJLoader.js'></script>
        <script src='-3D-main/js/gsap.min.js'></script>
        <script src="-3D-main/js/script.js"></script>
        <script>

          (function () {
            const _face = new THREE.Triangle();
      
            const _color = new THREE.Vector3();
      
            class MeshSurfaceSampler {
      
              constructor(mesh) {
      
                let geometry = mesh.geometry;
      
                if (!geometry.isBufferGeometry || geometry.attributes.position.itemSize !== 3) {
      
                  throw new Error('THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh.');
      
                }
      
                if (geometry.index) {
      
                  console.warn('THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.');
                  geometry = geometry.toNonIndexed();
      
                }
      
                this.geometry = geometry;
                this.randomFunction = Math.random;
                this.positionAttribute = this.geometry.getAttribute('position');
                this.colorAttribute = this.geometry.getAttribute('color');
                this.weightAttribute = null;
                this.distribution = null;
      
              }
      
              setWeightAttribute(name) {
      
                this.weightAttribute = name ? this.geometry.getAttribute(name) : null;
                return this;
      
              }
      
              build() {
      
                const positionAttribute = this.positionAttribute;
                const weightAttribute = this.weightAttribute;
                const faceWeights = new Float32Array(positionAttribute.count / 3); // Accumulate weights for each mesh face.
      
                for (let i = 0; i < positionAttribute.count; i += 3) {
      
                  let faceWeight = 1;
      
                  if (weightAttribute) {
      
                    faceWeight = weightAttribute.getX(i) + weightAttribute.getX(i + 1) + weightAttribute.getX(i + 2);
      
                  }
      
                  _face.a.fromBufferAttribute(positionAttribute, i);
      
                  _face.b.fromBufferAttribute(positionAttribute, i + 1);
      
                  _face.c.fromBufferAttribute(positionAttribute, i + 2);
      
                  faceWeight *= _face.getArea();
                  faceWeights[i / 3] = faceWeight;
      
                } // Store cumulative total face weights in an array, where weight index
                // corresponds to face index.
      
      
                this.distribution = new Float32Array(positionAttribute.count / 3);
                let cumulativeTotal = 0;
      
                for (let i = 0; i < faceWeights.length; i++) {
      
                  cumulativeTotal += faceWeights[i];
                  this.distribution[i] = cumulativeTotal;
      
                }
      
                return this;
      
              }
      
              setRandomGenerator(randomFunction) {
      
                this.randomFunction = randomFunction;
                return this;
      
              }
      
              sample(targetPosition, targetNormal, targetColor) {
      
                const cumulativeTotal = this.distribution[this.distribution.length - 1];
                const faceIndex = this.binarySearch(this.randomFunction() * cumulativeTotal);
                return this.sampleFace(faceIndex, targetPosition, targetNormal, targetColor);
      
              }
      
              binarySearch(x) {
      
                const dist = this.distribution;
                let start = 0;
                let end = dist.length - 1;
                let index = - 1;
      
                while (start <= end) {
      
                  const mid = Math.ceil((start + end) / 2);
      
                  if (mid === 0 || dist[mid - 1] <= x && dist[mid] > x) {
      
                    index = mid;
                    break;
      
                  } else if (x < dist[mid]) {
      
                    end = mid - 1;
      
                  } else {
      
                    start = mid + 1;
      
                  }
      
                }
      
                return index;
      
              }
      
              sampleFace(faceIndex, targetPosition, targetNormal, targetColor) {
      
                let u = this.randomFunction();
                let v = this.randomFunction();
      
                if (u + v > 1) {
      
                  u = 1 - u;
                  v = 1 - v;
      
                }
      
                _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3);
      
                _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1);
      
                _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2);
      
                targetPosition.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));
      
                if (targetNormal !== undefined) {
      
                  _face.getNormal(targetNormal);
      
                }
      
                if (targetColor !== undefined && this.colorAttribute !== undefined) {
      
                  _face.a.fromBufferAttribute(this.colorAttribute, faceIndex * 3);
      
                  _face.b.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 1);
      
                  _face.c.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 2);
      
                  _color.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));
      
                  targetColor.r = _color.x;
                  targetColor.g = _color.y;
                  targetColor.b = _color.z;
                }
                return this;
      
              }
      
            }
      
            THREE.MeshSurfaceSampler = MeshSurfaceSampler;
      
          })();
      
        </script>
        <script>
          (function () {
      
            const _object_pattern = /^[og]\s*(.+)?/; // mtllib file_reference
      
            const _material_library_pattern = /^mtllib /; // usemtl material_name
      
            const _material_use_pattern = /^usemtl /; // usemap map_name
      
            const _map_use_pattern = /^usemap /;
      
            const _vA = new THREE.Vector3();
      
            const _vB = new THREE.Vector3();
      
            const _vC = new THREE.Vector3();
      
            const _ab = new THREE.Vector3();
      
            const _cb = new THREE.Vector3();
      
            function ParserState() {
      
              const state = {
                objects: [],
                object: {},
                vertices: [],
                normals: [],
                colors: [],
                uvs: [],
                materials: {},
                materialLibraries: [],
                startObject: function (name, fromDeclaration) {
      
                  // If the current object (initial from reset) is not from a g/o declaration in the parsed
                  // file. We need to use it for the first parsed g/o to keep things in sync.
                  if (this.object && this.object.fromDeclaration === false) {
      
                    this.object.name = name;
                    this.object.fromDeclaration = fromDeclaration !== false;
                    return;
      
                  }
      
                  const previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;
      
                  if (this.object && typeof this.object._finalize === 'function') {
      
                    this.object._finalize(true);
      
                  }
      
                  this.object = {
                    name: name || '',
                    fromDeclaration: fromDeclaration !== false,
                    geometry: {
                      vertices: [],
                      normals: [],
                      colors: [],
                      uvs: [],
                      hasUVIndices: false
                    },
                    materials: [],
                    smooth: true,
                    startMaterial: function (name, libraries) {
      
                      const previous = this._finalize(false); // New usemtl declaration overwrites an inherited material, except if faces were declared
                      // after the material, then it must be preserved for proper MultiMaterial continuation.
      
      
                      if (previous && (previous.inherited || previous.groupCount <= 0)) {
      
                        this.materials.splice(previous.index, 1);
      
                      }
      
                      const material = {
                        index: this.materials.length,
                        name: name || '',
                        mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',
                        smooth: previous !== undefined ? previous.smooth : this.smooth,
                        groupStart: previous !== undefined ? previous.groupEnd : 0,
                        groupEnd: - 1,
                        groupCount: - 1,
                        inherited: false,
                        clone: function (index) {
      
                          const cloned = {
                            index: typeof index === 'number' ? index : this.index,
                            name: this.name,
                            mtllib: this.mtllib,
                            smooth: this.smooth,
                            groupStart: 0,
                            groupEnd: - 1,
                            groupCount: - 1,
                            inherited: false
                          };
                          cloned.clone = this.clone.bind(cloned);
                          return cloned;
      
                        }
                      };
                      this.materials.push(material);
                      return material;
      
                    },
                    currentMaterial: function () {
      
                      if (this.materials.length > 0) {
      
                        return this.materials[this.materials.length - 1];
      
                      }
      
                      return undefined;
      
                    },
                    _finalize: function (end) {
      
                      const lastMultiMaterial = this.currentMaterial();
      
                      if (lastMultiMaterial && lastMultiMaterial.groupEnd === - 1) {
      
                        lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
                        lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
                        lastMultiMaterial.inherited = false;
      
                      } // Ignore objects tail materials if no face declarations followed them before a new o/g started.
      
      
                      if (end && this.materials.length > 1) {
      
                        for (let mi = this.materials.length - 1; mi >= 0; mi--) {
      
                          if (this.materials[mi].groupCount <= 0) {
      
                            this.materials.splice(mi, 1);
      
                          }
      
                        }
      
                      } // Guarantee at least one empty material, this makes the creation later more straight forward.
      
      
                      if (end && this.materials.length === 0) {
      
                        this.materials.push({
                          name: '',
                          smooth: this.smooth
                        });
      
                      }
      
                      return lastMultiMaterial;
      
                    }
                  }; // Inherit previous objects material.
                  // Spec tells us that a declared material must be set to all objects until a new material is declared.
                  // If a usemtl declaration is encountered while this new object is being parsed, it will
                  // overwrite the inherited material. Exception being that there was already face declarations
                  // to the inherited material, then it will be preserved for proper MultiMaterial continuation.
      
                  if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {
      
                    const declared = previousMaterial.clone(0);
                    declared.inherited = true;
                    this.object.materials.push(declared);
      
                  }
      
                  this.objects.push(this.object);
      
                },
                finalize: function () {
      
                  if (this.object && typeof this.object._finalize === 'function') {
      
                    this.object._finalize(true);
      
                  }
      
                },
                parseVertexIndex: function (value, len) {
      
                  const index = parseInt(value, 10);
                  return (index >= 0 ? index - 1 : index + len / 3) * 3;
      
                },
                parseNormalIndex: function (value, len) {
      
                  const index = parseInt(value, 10);
                  return (index >= 0 ? index - 1 : index + len / 3) * 3;
      
                },
                parseUVIndex: function (value, len) {
      
                  const index = parseInt(value, 10);
                  return (index >= 0 ? index - 1 : index + len / 2) * 2;
      
                },
                addVertex: function (a, b, c) {
      
                  const src = this.vertices;
                  const dst = this.object.geometry.vertices;
                  dst.push(src[a + 0], src[a + 1], src[a + 2]);
                  dst.push(src[b + 0], src[b + 1], src[b + 2]);
                  dst.push(src[c + 0], src[c + 1], src[c + 2]);
      
                },
                addVertexPoint: function (a) {
      
                  const src = this.vertices;
                  const dst = this.object.geometry.vertices;
                  dst.push(src[a + 0], src[a + 1], src[a + 2]);
      
                },
                addVertexLine: function (a) {
      
                  const src = this.vertices;
                  const dst = this.object.geometry.vertices;
                  dst.push(src[a + 0], src[a + 1], src[a + 2]);
      
                },
                addNormal: function (a, b, c) {
      
                  const src = this.normals;
                  const dst = this.object.geometry.normals;
                  dst.push(src[a + 0], src[a + 1], src[a + 2]);
                  dst.push(src[b + 0], src[b + 1], src[b + 2]);
                  dst.push(src[c + 0], src[c + 1], src[c + 2]);
      
                },
                addFaceNormal: function (a, b, c) {
      
                  const src = this.vertices;
                  const dst = this.object.geometry.normals;
      
                  _vA.fromArray(src, a);
      
                  _vB.fromArray(src, b);
      
                  _vC.fromArray(src, c);
      
                  _cb.subVectors(_vC, _vB);
      
                  _ab.subVectors(_vA, _vB);
      
                  _cb.cross(_ab);
      
                  _cb.normalize();
      
                  dst.push(_cb.x, _cb.y, _cb.z);
                  dst.push(_cb.x, _cb.y, _cb.z);
                  dst.push(_cb.x, _cb.y, _cb.z);
      
                },
                addColor: function (a, b, c) {
      
                  const src = this.colors;
                  const dst = this.object.geometry.colors;
                  if (src[a] !== undefined) dst.push(src[a + 0], src[a + 1], src[a + 2]);
                  if (src[b] !== undefined) dst.push(src[b + 0], src[b + 1], src[b + 2]);
                  if (src[c] !== undefined) dst.push(src[c + 0], src[c + 1], src[c + 2]);
      
                },
                addUV: function (a, b, c) {
      
                  const src = this.uvs;
                  const dst = this.object.geometry.uvs;
                  dst.push(src[a + 0], src[a + 1]);
                  dst.push(src[b + 0], src[b + 1]);
                  dst.push(src[c + 0], src[c + 1]);
      
                },
                addDefaultUV: function () {
      
                  const dst = this.object.geometry.uvs;
                  dst.push(0, 0);
                  dst.push(0, 0);
                  dst.push(0, 0);
      
                },
                addUVLine: function (a) {
      
                  const src = this.uvs;
                  const dst = this.object.geometry.uvs;
                  dst.push(src[a + 0], src[a + 1]);
      
                },
                addFace: function (a, b, c, ua, ub, uc, na, nb, nc) {
      
                  const vLen = this.vertices.length;
                  let ia = this.parseVertexIndex(a, vLen);
                  let ib = this.parseVertexIndex(b, vLen);
                  let ic = this.parseVertexIndex(c, vLen);
                  this.addVertex(ia, ib, ic);
                  this.addColor(ia, ib, ic); // normals
      
                  if (na !== undefined && na !== '') {
      
                    const nLen = this.normals.length;
                    ia = this.parseNormalIndex(na, nLen);
                    ib = this.parseNormalIndex(nb, nLen);
                    ic = this.parseNormalIndex(nc, nLen);
                    this.addNormal(ia, ib, ic);
      
                  } else {
      
                    this.addFaceNormal(ia, ib, ic);
      
                  } // uvs
      
      
                  if (ua !== undefined && ua !== '') {
      
                    const uvLen = this.uvs.length;
                    ia = this.parseUVIndex(ua, uvLen);
                    ib = this.parseUVIndex(ub, uvLen);
                    ic = this.parseUVIndex(uc, uvLen);
                    this.addUV(ia, ib, ic);
                    this.object.geometry.hasUVIndices = true;
      
                  } else {
      
                    // add placeholder values (for inconsistent face definitions)
                    this.addDefaultUV();
      
                  }
      
                },
                addPointGeometry: function (vertices) {
      
                  this.object.geometry.type = 'Points';
                  const vLen = this.vertices.length;
      
                  for (let vi = 0, l = vertices.length; vi < l; vi++) {
      
                    const index = this.parseVertexIndex(vertices[vi], vLen);
                    this.addVertexPoint(index);
                    this.addColor(index);
      
                  }
      
                },
                addLineGeometry: function (vertices, uvs) {
      
                  this.object.geometry.type = 'Line';
                  const vLen = this.vertices.length;
                  const uvLen = this.uvs.length;
      
                  for (let vi = 0, l = vertices.length; vi < l; vi++) {
      
                    this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));
      
                  }
      
                  for (let uvi = 0, l = uvs.length; uvi < l; uvi++) {
      
                    this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));
      
                  }
      
                }
              };
              state.startObject('', false);
              return state;
      
            } //
      
      
            class OBJLoader extends THREE.Loader {
      
              constructor(manager) {
      
                super(manager);
                this.materials = null;
      
              }
      
              load(url, onLoad, onProgress, onError) {
      
                const scope = this;
                const loader = new THREE.FileLoader(this.manager);
                loader.setPath(this.path);
                loader.setRequestHeader(this.requestHeader);
                loader.setWithCredentials(this.withCredentials);
                loader.load(url, function (text) {
      
                  try {
      
                    onLoad(scope.parse(text));
      
                  } catch (e) {
      
                    if (onError) {
      
                      onError(e);
      
                    } else {
      
                      console.error(e);
      
                    }
      
                    scope.manager.itemError(url);
      
                  }
      
                }, onProgress, onError);
      
              }
      
              setMaterials(materials) {
      
                this.materials = materials;
                return this;
      
              }
      
              parse(text) {
      
                const state = new ParserState();
      
                if (text.indexOf('\r\n') !== - 1) {
      
                  // This is faster than String.split with regex that splits on both
                  text = text.replace(/\r\n/g, '\n');
      
                }
      
                if (text.indexOf('\\\n') !== - 1) {
      
                  // join lines separated by a line continuation character (\)
                  text = text.replace(/\\\n/g, '');
      
                }
      
                const lines = text.split('\n');
                let line = '',
                  lineFirstChar = '';
                let lineLength = 0;
                let result = []; // Faster to just trim left side of the line. Use if available.
      
                const trimLeft = typeof ''.trimLeft === 'function';
      
                for (let i = 0, l = lines.length; i < l; i++) {
      
                  line = lines[i];
                  line = trimLeft ? line.trimLeft() : line.trim();
                  lineLength = line.length;
                  if (lineLength === 0) continue;
                  lineFirstChar = line.charAt(0); // @todo invoke passed in handler if any
      
                  if (lineFirstChar === '#') continue;
      
                  if (lineFirstChar === 'v') {
      
                    const data = line.split(/\s+/);
      
                    switch (data[0]) {
      
                      case 'v':
                        state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
      
                        if (data.length >= 7) {
      
                          state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));
      
                        } else {
      
                          // if no colors are defined, add placeholders so color and vertex indices match
                          state.colors.push(undefined, undefined, undefined);
      
                        }
      
                        break;
      
                      case 'vn':
                        state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
                        break;
      
                      case 'vt':
                        state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));
                        break;
      
                    }
      
                  } else if (lineFirstChar === 'f') {
      
                    const lineData = line.substr(1).trim();
                    const vertexData = lineData.split(/\s+/);
                    const faceVertices = []; // Parse the face vertex data into an easy to work with format
      
                    for (let j = 0, jl = vertexData.length; j < jl; j++) {
      
                      const vertex = vertexData[j];
      
                      if (vertex.length > 0) {
      
                        const vertexParts = vertex.split('/');
                        faceVertices.push(vertexParts);
      
                      }
      
                    } // Draw an edge between the first vertex and all subsequent vertices to form an n-gon
      
      
                    const v1 = faceVertices[0];
      
                    for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {
      
                      const v2 = faceVertices[j];
                      const v3 = faceVertices[j + 1];
                      state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);
      
                    }
      
                  } else if (lineFirstChar === 'l') {
      
                    const lineParts = line.substring(1).trim().split(' ');
                    let lineVertices = [];
                    const lineUVs = [];
      
                    if (line.indexOf('/') === - 1) {
      
                      lineVertices = lineParts;
      
                    } else {
      
                      for (let li = 0, llen = lineParts.length; li < llen; li++) {
      
                        const parts = lineParts[li].split('/');
                        if (parts[0] !== '') lineVertices.push(parts[0]);
                        if (parts[1] !== '') lineUVs.push(parts[1]);
      
                      }
      
                    }
      
                    state.addLineGeometry(lineVertices, lineUVs);
      
                  } else if (lineFirstChar === 'p') {
      
                    const lineData = line.substr(1).trim();
                    const pointData = lineData.split(' ');
                    state.addPointGeometry(pointData);
      
                  } else if ((result = _object_pattern.exec(line)) !== null) {
      
                    // o object_name
                    // or
                    // g group_name
                    // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869
                    // let name = result[ 0 ].substr( 1 ).trim();
                    const name = (' ' + result[0].substr(1).trim()).substr(1);
                    state.startObject(name);
      
                  } else if (_material_use_pattern.test(line)) {
      
                    // material
                    state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);
      
                  } else if (_material_library_pattern.test(line)) {
      
                    // mtl file
                    state.materialLibraries.push(line.substring(7).trim());
      
                  } else if (_map_use_pattern.test(line)) {
      
                    // the line is parsed but ignored since the loader assumes textures are defined MTL files
                    // (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)
                    console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
      
                  } else if (lineFirstChar === 's') {
      
                    result = line.split(' '); // smooth shading
                    // @todo Handle files that have varying smooth values for a set of faces inside one geometry,
                    // but does not define a usemtl for each face set.
                    // This should be detected and a dummy material created (later MultiMaterial and geometry groups).
                    // This requires some care to not create extra material on each smooth value for "normal" obj files.
                    // where explicit usemtl defines geometry groups.
                    // Example asset: examples/models/obj/cerberus/Cerberus.obj
      
                    /*
                     * http://paulbourke.net/dataformats/obj/
                     * or
                     * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf
                     *
                     * From chapter "Grouping" Syntax explanation "s group_number":
                     * "group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.
                     * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form
                     * surfaces, smoothing groups are either turned on or off; there is no difference between values greater
                     * than 0."
                     */
      
                    if (result.length > 1) {
      
                      const value = result[1].trim().toLowerCase();
                      state.object.smooth = value !== '0' && value !== 'off';
      
                    } else {
      
                      // ZBrush can produce "s" lines #11707
                      state.object.smooth = true;
      
                    }
      
                    const material = state.object.currentMaterial();
                    if (material) material.smooth = state.object.smooth;
      
                  } else {
      
                    // Handle null terminated files without exception
                    if (line === '\0') continue;
                    console.warn('THREE.OBJLoader: Unexpected line: "' + line + '"');
      
                  }
      
                }
      
                state.finalize();
                const container = new THREE.Group();
                container.materialLibraries = [].concat(state.materialLibraries);
                const hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0);
      
                if (hasPrimitives === true) {
      
                  for (let i = 0, l = state.objects.length; i < l; i++) {
      
                    const object = state.objects[i];
                    const geometry = object.geometry;
                    const materials = object.materials;
                    const isLine = geometry.type === 'Line';
                    const isPoints = geometry.type === 'Points';
                    let hasVertexColors = false; // Skip o/g line declarations that did not follow with any faces
      
                    if (geometry.vertices.length === 0) continue;
                    const buffergeometry = new THREE.BufferGeometry();
                    buffergeometry.setAttribute('position', new THREE.Float32BufferAttribute(geometry.vertices, 3));
      
                    if (geometry.normals.length > 0) {
      
                      buffergeometry.setAttribute('normal', new THREE.Float32BufferAttribute(geometry.normals, 3));
      
                    }
      
                    if (geometry.colors.length > 0) {
      
                      hasVertexColors = true;
                      buffergeometry.setAttribute('color', new THREE.Float32BufferAttribute(geometry.colors, 3));
      
                    }
      
                    if (geometry.hasUVIndices === true) {
      
                      buffergeometry.setAttribute('uv', new THREE.Float32BufferAttribute(geometry.uvs, 2));
      
                    } // Create materials
      
      
                    const createdMaterials = [];
      
                    for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {
      
                      const sourceMaterial = materials[mi];
                      const materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;
                      let material = state.materials[materialHash];
      
                      if (this.materials !== null) {
      
                        material = this.materials.create(sourceMaterial.name); // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.
      
                        if (isLine && material && !(material instanceof THREE.LineBasicMaterial)) {
      
                          const materialLine = new THREE.LineBasicMaterial();
                          THREE.Material.prototype.copy.call(materialLine, material);
                          materialLine.color.copy(material.color);
                          material = materialLine;
      
                        } else if (isPoints && material && !(material instanceof THREE.PointsMaterial)) {
      
                          const materialPoints = new THREE.PointsMaterial({
                            size: 10,
                            sizeAttenuation: false
                          });
                          THREE.Material.prototype.copy.call(materialPoints, material);
                          materialPoints.color.copy(material.color);
                          materialPoints.map = material.map;
                          material = materialPoints;
      
                        }
      
                      }
      
                      if (material === undefined) {
      
                        if (isLine) {
      
                          material = new THREE.LineBasicMaterial();
      
                        } else if (isPoints) {
      
                          material = new THREE.PointsMaterial({
                            size: 1,
                            sizeAttenuation: false
                          });
      
                        } else {
      
                          material = new THREE.MeshPhongMaterial();
      
                        }
      
                        material.name = sourceMaterial.name;
                        material.flatShading = sourceMaterial.smooth ? false : true;
                        material.vertexColors = hasVertexColors;
                        state.materials[materialHash] = material;
      
                      }
      
                      createdMaterials.push(material);
      
                    } // Create mesh
      
      
                    let mesh;
      
                    if (createdMaterials.length > 1) {
      
                      for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {
      
                        const sourceMaterial = materials[mi];
                        buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);
      
                      }
      
                      if (isLine) {
      
                        mesh = new THREE.LineSegments(buffergeometry, createdMaterials);
      
                      } else if (isPoints) {
      
                        mesh = new THREE.Points(buffergeometry, createdMaterials);
      
                      } else {
      
                        mesh = new THREE.Mesh(buffergeometry, createdMaterials);
      
                      }
      
                    } else {
      
                      if (isLine) {
      
                        mesh = new THREE.LineSegments(buffergeometry, createdMaterials[0]);
      
                      } else if (isPoints) {
      
                        mesh = new THREE.Points(buffergeometry, createdMaterials[0]);
      
                      } else {
      
                        mesh = new THREE.Mesh(buffergeometry, createdMaterials[0]);
      
                      }
      
                    }
      
                    mesh.name = object.name;
                    container.add(mesh);
      
                  }
      
                } else {
      
                  // if there is only the default parser state object with no geometry data, interpret data as point cloud
                  if (state.vertices.length > 0) {
      
                    const material = new THREE.PointsMaterial({
                      size: 1,
                      sizeAttenuation: false
                    });
                    const buffergeometry = new THREE.BufferGeometry();
                    buffergeometry.setAttribute('position', new THREE.Float32BufferAttribute(state.vertices, 3));
      
                    if (state.colors.length > 0 && state.colors[0] !== undefined) {
      
                      buffergeometry.setAttribute('color', new THREE.Float32BufferAttribute(state.colors, 3));
                      material.vertexColors = true;
      
                    }
      
                    const points = new THREE.Points(buffergeometry, material);
                    container.add(points);
      
                  }
      
                }
      
                return container;
      
              }
      
            }
      
            THREE.OBJLoader = OBJLoader;
      
          })();
        </script>
      </div>
    </div>
  </div>

  <script>
    // 顯示 3D 場景
    function show3D() {
      document.querySelector('.ocean').style.display = 'none';
      document.querySelector('.scene').style.display = 'flex';
      document.querySelector('#gobackButton').style.display = 'block';
    }

    // 返回主頁面
    function goBack() {
      document.querySelector('.scene').style.display = 'none';
      document.querySelector('.ocean').style.display = 'flex';
      document.querySelector('#gobackButton').style.display = 'none';
    }

    function scrollScreen(direction) {
      const screen = document.querySelector('.screen');
      const pageWidth = screen.offsetWidth;
      screen.scrollBy({
        left: direction * pageWidth,
        behavior: 'smooth',
      });
    }

    // 設定泡泡數量
    const bubbleCount = 20;
    const ocean = document.querySelector('.ocean');

    // 動態生成泡泡
    for (let i = 0; i < bubbleCount; i++) {
      const bubble = document.createElement('div');
      bubble.classList.add('bubble');

      // 隨機設定 x 軸位置
      const randomX = Math.random() * 90 + 5;
      bubble.style.left = `${randomX}%`;

      // 隨機設定動畫持續時間
      const randomDuration = 6 + Math.random() * 4;
      bubble.style.animationDuration = `${randomDuration}s`;

      // 隨機設定大小
      const randomSize = 20 + Math.random() * 30;
      bubble.style.width = `${randomSize}px`;
      bubble.style.height = `${randomSize}px`;

      ocean.appendChild(bubble);
    }

    // 選取所有 .logo-team
    const logoTeamElements = document.querySelectorAll('.logo-team');

    let totalDelay = 2;
    // 設定每個 .logo-team 的動畫延遲
    logoTeamElements.forEach((logoTeam, index) => {
      const delay = 1 + index * 0.5; // 每個 .logo-team 增加 0.5 秒的延遲
      totalDelay += 1 + 0.5;

      logoTeam.style.animationDelay = `${delay}s`;

      setTimeout(() => {
        logoTeam.classList.add('play-text'); // 添加啟用文字動畫的類
      }, delay * 1000); // 計算實際的動畫時間
    });

    // console.log(totalDelay);

    // 雜訊層動畫
    const staticNoise = document.querySelector('.static-noise');
    setTimeout(() => {
      staticNoise.classList.add('fade-out');
    }, totalDelay * 1000);

    const nmixxText = document.querySelector('.nmixx-text');
    nmixxText.style.animationDelay = `${totalDelay}s`;

  </script>
</body>
</html>
